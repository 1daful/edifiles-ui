import { Client as e, createRequest as r } from "@urql/core";

export * from "@urql/core";

import { isRef as u, ref as a, getCurrentInstance as s, provide as l, inject as t, reactive as n, shallowRef as i, watchEffect as o, onBeforeUnmount as v, onMounted as c } from "vue";

import { subscribe as p, onEnd as f, toPromise as y, take as P, filter as b, onPush as d } from "wonka";

var x = new WeakMap;

function provideClient(r) {
  var t;
  if (!u(r)) {
    t = a(r instanceof e ? r : new e(r));
  } else {
    t = r;
  }
  var n = s();
  if (n) {
    x.set(n, t);
  }
  l("$urql", t);
  return t.value;
}

function install(r, s) {
  var l;
  if (!u(s)) {
    l = a(s instanceof e ? s : new e(s));
  } else {
    l = s;
  }
  r.provide("$urql", l);
}

function useClient() {
  var e = s();
  if ("production" !== process.env.NODE_ENV && !e) {
    throw new Error("use* functions may only be called during the `setup()` or other lifecycle hooks.");
  }
  var r = t("$urql");
  if (!r && e) {
    r = x.get(e);
  }
  if ("production" !== process.env.NODE_ENV && !r) {
    throw new Error("No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?");
  }
  return r;
}

function unwrapPossibleProxy(e) {
  return e && u(e) ? e.value : e;
}

var updateShallowRef = (e, r) => {
  for (var u in r) {
    if (e.value[u] !== r[u]) {
      e.value = r;
      return;
    }
  }
};

var h = {
  flush: "pre"
};

function useQuery(e) {
  return callUseQuery(e);
}

function callUseQuery(e, s = useClient(), l = []) {
  var t = n(e);
  var v = a();
  var c = a(!1);
  var y = a(!1);
  var P = a();
  var b = a();
  var d = a();
  var x = u(e.pause) ? e.pause : a(!!e.pause);
  var w = i({
    request: r(unwrapPossibleProxy(t.query), unwrapPossibleProxy(t.variables)),
    requestPolicy: unwrapPossibleProxy(t.requestPolicy),
    isPaused: x.value
  });
  var q = a();
  l.push(o((() => {
    updateShallowRef(w, {
      request: r(unwrapPossibleProxy(t.query), unwrapPossibleProxy(t.variables)),
      requestPolicy: unwrapPossibleProxy(t.requestPolicy),
      isPaused: x.value
    });
  }), h));
  l.push(o((() => {
    q.value = !w.value.isPaused ? s.value.executeQuery(w.value.request, {
      requestPolicy: unwrapPossibleProxy(t.requestPolicy),
      ...unwrapPossibleProxy(t.context)
    }) : void 0;
  }), h));
  var E = {
    data: v,
    stale: c,
    error: P,
    operation: b,
    extensions: d,
    fetching: y,
    isPaused: x,
    executeQuery(e) {
      var r = q.value = s.value.executeQuery(w.value.request, {
        requestPolicy: unwrapPossibleProxy(t.requestPolicy),
        ...t.context,
        ...e
      });
      return {
        ...m,
        then(e, u) {
          var a;
          return new Promise((e => {
            var u = !1;
            a = p((() => {
              if (!E.fetching.value && !E.stale.value) {
                if (a) {
                  a.unsubscribe();
                }
                u = !0;
                e(E);
              }
            }))(r);
            if (u) {
              a.unsubscribe();
            }
          })).then(e, u);
        }
      };
    },
    pause() {
      x.value = !0;
    },
    resume() {
      x.value = !1;
    }
  };
  l.push(o((e => {
    if (q.value) {
      y.value = !0;
      c.value = !1;
      e(p((e => {
        v.value = e.data;
        c.value = !!e.stale;
        y.value = !1;
        P.value = e.error;
        b.value = e.operation;
        d.value = e.extensions;
      }))(f((() => {
        y.value = !1;
        c.value = !1;
      }))(q.value)).unsubscribe);
    } else {
      y.value = !1;
      c.value = !1;
    }
  }), {
    flush: "sync"
  }));
  var m = {
    ...E,
    then(e, r) {
      var u;
      return new Promise((e => {
        if (!q.value) {
          return e(E);
        }
        var r = !1;
        u = p((() => {
          if (!E.fetching.value && !E.stale.value) {
            if (u) {
              u.unsubscribe();
            }
            r = !0;
            e(E);
          }
        }))(q.value);
        if (r) {
          u.unsubscribe();
        }
      })).then(e, r);
    }
  };
  return m;
}

function useMutation(e) {
  return callUseMutation(e);
}

function callUseMutation(e, u = useClient()) {
  var s = a();
  var l = a(!1);
  var t = a(!1);
  var n = a();
  var i = a();
  var o = a();
  return {
    data: s,
    stale: l,
    fetching: t,
    error: n,
    operation: i,
    extensions: o,
    executeMutation(a, v) {
      t.value = !0;
      return y(P(1)(b((e => !e.hasNext))(d((e => {
        s.value = e.data;
        l.value = e.stale;
        t.value = !1;
        n.value = e.error;
        i.value = e.operation;
        o.value = e.extensions;
      }))(u.value.executeMutation(r(e, unwrapPossibleProxy(a)), v || {})))));
    }
  };
}

var w = {
  flush: "pre"
};

function useSubscription(e, r) {
  return callUseSubscription(e, r);
}

function callUseSubscription(e, s, l = useClient(), t = []) {
  var v = n(e);
  var c = a();
  var y = a(!1);
  var P = a(!1);
  var b = a();
  var d = a();
  var x = a();
  var h = a(s);
  var q = u(e.pause) ? e.pause : a(!!e.pause);
  var E = i({
    request: r(unwrapPossibleProxy(v.query), unwrapPossibleProxy(v.variables)),
    isPaused: q.value
  });
  var m = a();
  t.push(o((() => {
    updateShallowRef(E, {
      request: r(unwrapPossibleProxy(v.query), unwrapPossibleProxy(v.variables)),
      isPaused: q.value
    });
  }), w));
  t.push(o((() => {
    m.value = !q.value ? l.value.executeSubscription(E.value.request, {
      ...unwrapPossibleProxy(v.context)
    }) : void 0;
  }), w));
  t.push(o((e => {
    if (m.value) {
      P.value = !0;
      e(p((e => {
        P.value = !0;
        c.value = void 0 !== e.data ? "function" == typeof h.value ? h.value(c.value, e.data) : e.data : e.data, 
        b.value = e.error;
        x.value = e.extensions;
        y.value = !!e.stale;
        d.value = e.operation;
      }))(f((() => {
        P.value = !1;
      }))(m.value)).unsubscribe);
    } else {
      P.value = !1;
    }
  }), w));
  var N = {
    data: c,
    stale: y,
    error: b,
    operation: d,
    extensions: x,
    fetching: P,
    isPaused: q,
    executeSubscription(e) {
      m.value = l.value.executeSubscription(E.value.request, {
        ...unwrapPossibleProxy(v.context),
        ...e
      });
      return N;
    },
    pause() {
      q.value = !0;
    },
    resume() {
      q.value = !1;
    }
  };
  return N;
}

function useClientHandle() {
  var e = useClient();
  var r = [];
  v((() => {
    var e;
    while (e = r.shift()) {
      e();
    }
  }));
  var u = {
    client: e.value,
    useQuery: u => callUseQuery(u, e, r),
    useSubscription: (u, a) => callUseSubscription(u, a, e, r),
    useMutation: r => callUseMutation(r, e)
  };
  if ("production" !== process.env.NODE_ENV) {
    c((() => {
      Object.assign(u, {
        useQuery(u) {
          if ("production" !== process.env.NODE_ENV && !s()) {
            throw new Error("`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseQuery(u, e, r);
        },
        useSubscription(u, a) {
          if ("production" !== process.env.NODE_ENV && !s()) {
            throw new Error("`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseSubscription(u, a, e, r);
        }
      });
    }));
  }
  return u;
}

export { install as default, install, provideClient, useClientHandle, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql-vue.mjs.map
