{"version":3,"file":"urql-vue.min.mjs","sources":["../src/useClient.ts","../src/utils.ts","../src/useQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useClientHandle.ts"],"sourcesContent":["import { App, getCurrentInstance, inject, provide, Ref, isRef, ref } from 'vue';\nimport { Client, ClientOptions } from '@urql/core';\n\nconst clientsPerInstance = new WeakMap<{}, Ref<Client>>();\n\n/** Provides a {@link Client} to a component’s children.\n *\n * @param opts - {@link ClientOptions}, a {@link Client}, or a reactive ref object of a `Client`.\n *\n * @remarks\n * `provideClient` provides a {@link Client} to `@urql/vue`’s GraphQL\n * functions in children components.\n *\n * Hint: GraphQL functions and {@link useClient} will see the\n * provided `Client`, even if `provideClient` has been called\n * in the same component’s `setup` function.\n *\n * @example\n * ```ts\n * import { provideClient } from '@urql/vue';\n * // All of `@urql/core` is also re-exported by `@urql/vue`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * export default {\n *   setup() {\n *     provideClient(new Client({\n *       url: 'https://API',\n *       exchanges: [cacheExchange, fetchExchange],\n *     }));\n *   },\n * };\n * ```\n */\nexport function provideClient(opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n\n  const instance = getCurrentInstance();\n  if (instance) {\n    clientsPerInstance.set(instance, client);\n  }\n\n  provide('$urql', client);\n  return client.value;\n}\n\n/** Provides a {@link Client} to a Vue app.\n *\n * @param app - the Vue {@link App}\n * @param opts - {@link ClientOptions}, a {@link Client}, or a reactive ref object of a `Client`.\n *\n * @remarks\n * `install` provides a {@link Client} to `@urql/vue`’s GraphQL\n * functions in a Vue app.\n *\n * @example\n * ```ts\n * import * as urql from '@urql/vue';\n * // All of `@urql/core` is also re-exported by `@urql/vue`:\n * import { cacheExchange, fetchExchange } from '@urql/core';\n *\n * import { createApp } from 'vue';\n * import Root from './App.vue';\n *\n * const app = createApp(Root);\n * app.use(urql, {\n *   url: 'http://localhost:3000/graphql',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n * ```\n */\nexport function install(app: App, opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n  app.provide('$urql', client);\n}\n\n/** Returns a provided reactive ref object of a {@link Client}.\n *\n * @remarks\n * `useClient` may be called in Vue `setup` functions to retrieve a\n * reactive rev object of a {@link Client} that’s previously been\n * provided with {@link provideClient} in the current or a parent’s\n * `setup` function.\n *\n * @throws\n * In development, if `useClient` is called outside of a Vue `setup`\n * function or no {@link Client} was provided, an error will be thrown.\n */\nexport function useClient(): Ref<Client> {\n  const instance = getCurrentInstance();\n  if (process.env.NODE_ENV !== 'production' && !instance) {\n    throw new Error(\n      'use* functions may only be called during the `setup()` or other lifecycle hooks.'\n    );\n  }\n\n  let client = inject('$urql') as Ref<Client> | undefined;\n  if (!client && instance) {\n    client = clientsPerInstance.get(instance);\n  }\n\n  if (process.env.NODE_ENV !== 'production' && !client) {\n    throw new Error(\n      'No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?'\n    );\n  }\n\n  return client!;\n}\n","import { GraphQLRequest, AnyVariables } from '@urql/core';\nimport { Ref, ShallowRef, isRef } from 'vue';\n\nexport function unwrapPossibleProxy<V>(possibleProxy: V | Ref<V>): V {\n  return possibleProxy && isRef(possibleProxy)\n    ? possibleProxy.value\n    : possibleProxy;\n}\n\nexport interface RequestState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  request: GraphQLRequest<Data, Variables>;\n  isPaused: boolean;\n}\n\nexport function createRequestState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  request: GraphQLRequest<Data, Variables>,\n  isPaused: boolean\n): RequestState<Data, Variables> {\n  return { request, isPaused };\n}\n\nexport const updateShallowRef = <T extends Record<string, any>>(\n  ref: ShallowRef<T>,\n  next: T\n) => {\n  for (const key in next) {\n    if (ref.value[key] !== next[key]) {\n      ref.value = next;\n      return;\n    }\n  }\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport {\n  WatchStopHandle,\n  Ref,\n  shallowRef,\n  ref,\n  watchEffect,\n  reactive,\n  isRef,\n} from 'vue';\n\nimport { Subscription, Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport {\n  Client,\n  AnyVariables,\n  OperationResult,\n  GraphQLRequestParams,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  Operation,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy, updateShallowRef } from './utils';\n\ntype MaybeRef<T> = T | Ref<T>;\ntype MaybeRefObj<T extends {}> = { [K in keyof T]: MaybeRef<T[K]> };\n\n/** Input arguments for the {@link useQuery} function.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: MaybeRef<RequestPolicy>;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * const result = useQuery({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: MaybeRef<Partial<OperationContext>>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. This will pause the query until {@link UseQueryState.resume}\n   * is called, or, if `pause` is a reactive ref of a boolean, until this\n   * ref changes to `true`.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: MaybeRef<boolean>;\n} & MaybeRefObj<GraphQLRequestParams<Data, Variables>>;\n\n/** State of the current query, your {@link useQuery} function is executing.\n *\n * @remarks\n * `UseQueryState` is returned by {@link useQuery} and\n * gives you the updating {@link OperationResult} of\n * GraphQL queries.\n *\n * Each value that is part of the result is wrapped in a reactive ref\n * and updates as results come in.\n *\n * Hint: Even when the query and variables update, the previous state of\n * the last result is preserved, which allows you to display the\n * previous state, while implementing a loading indicator separately.\n */\nexport interface UseQueryState<T = any, V extends AnyVariables = AnyVariables> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` receives a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: Ref<boolean>;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed query. */\n  data: Ref<T | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed query. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed query. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Indicates whether {@link useQuery} is currently paused.\n   *\n   * @remarks\n   * When `useQuery` has been paused, it will stop receiving updates\n   * from the {@link Client} and won’t execute query operations, until\n   * {@link UseQueryArgs.pause} becomes `true` or {@link UseQueryState.resume}\n   * is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  isPaused: Ref<boolean>;\n  /** Resumes {@link useQuery} if it’s currently paused.\n   *\n   * @remarks\n   * Resumes or starts {@link useQuery}’s query, if it’s currently paused.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  resume(): void;\n  /** Pauses {@link useQuery} to stop it from executing the query.\n   *\n   * @remarks\n   * Pauses {@link useQuery}’s query, which stops it from receiving updates\n   * from the {@link Client} and to stop the ongoing query operation.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause(): void;\n  /** Triggers {@link useQuery} to execute a new GraphQL query operation.\n   *\n   * @param opts - optionally, context options that will be merged with\n   * {@link UseQueryArgs.context} and the `Client`’s options.\n   *\n   * @remarks\n   * When called, {@link useQuery} will re-execute the GraphQL query operation\n   * it currently holds, unless it’s currently paused.\n   *\n   * This is useful for re-executing a query and get a new network result,\n   * by passing a new request policy.\n   *\n   * ```ts\n   * const result = useQuery({ query });\n   *\n   * const refresh = () => {\n   *   // Re-execute the query with a network-only policy, skipping the cache\n   *   result.executeQuery({ requestPolicy: 'network-only' });\n   * };\n   * ```\n   */\n  executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V>;\n}\n\n/** Return value of {@link useQuery}, which is an awaitable {@link UseQueryState}.\n *\n * @remarks\n * {@link useQuery} returns a {@link UseQueryState} but may also be\n * awaited inside a Vue `async setup()` function. If it’s awaited\n * the query is executed before resolving.\n */\nexport type UseQueryResponse<\n  T,\n  V extends AnyVariables = AnyVariables\n> = UseQueryState<T, V> & PromiseLike<UseQueryState<T, V>>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\n/** Function to run a GraphQL query and get reactive GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} object.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed inside\n * Vue `setup` functions.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * provided {@link Client}.\n *\n * The returned result’s reactive values update when the `Client` has\n * new results for the query, and changes when your input `args` change.\n *\n * Additionally, `useQuery` may also be awaited inside an `async setup()`\n * function to use Vue’s Suspense feature.\n *\n * @see {@link https://urql.dev/goto/docs/basics/vue#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from '@urql/vue';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useQuery({ query: TodosQuery });\n *     return { data: result.data };\n *   },\n * };\n * ```\n */\nexport function useQuery<T = any, V extends AnyVariables = AnyVariables>(\n  args: UseQueryArgs<T, V>\n): UseQueryResponse<T, V> {\n  return callUseQuery(args);\n}\n\nexport function callUseQuery<T = any, V extends AnyVariables = AnyVariables>(\n  _args: UseQueryArgs<T, V>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseQueryResponse<T, V> {\n  const args = reactive(_args);\n\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const input = shallowRef({\n    request: createRequest<T, V>(\n      unwrapPossibleProxy(args.query as any),\n      unwrapPossibleProxy<V>(args.variables as V)\n    ),\n    requestPolicy: unwrapPossibleProxy(args.requestPolicy),\n    isPaused: isPaused.value,\n  });\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      updateShallowRef(input, {\n        request: createRequest<T, V>(\n          unwrapPossibleProxy(args.query as any),\n          unwrapPossibleProxy<V>(args.variables as V)\n        ),\n        requestPolicy: unwrapPossibleProxy(args.requestPolicy),\n        isPaused: isPaused.value,\n      });\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !input.value.isPaused\n        ? client.value.executeQuery<T, V>(input.value.request, {\n            requestPolicy: unwrapPossibleProxy(\n              args.requestPolicy\n            ) as RequestPolicy,\n            ...unwrapPossibleProxy(args.context),\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  const state: UseQueryState<T, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V> {\n      const s = (source.value = client.value.executeQuery<T, V>(\n        input.value.request,\n        {\n          requestPolicy: unwrapPossibleProxy(\n            args.requestPolicy\n          ) as RequestPolicy,\n          ...args.context,\n          ...opts,\n        }\n      ));\n\n      return {\n        ...response,\n        then(onFulfilled, onRejected) {\n          let sub: Subscription | void;\n          return new Promise<UseQueryState<T, V>>(resolve => {\n            let hasResult = false;\n            sub = pipe(\n              s,\n              subscribe(() => {\n                if (!state.fetching.value && !state.stale.value) {\n                  if (sub) sub.unsubscribe();\n                  hasResult = true;\n                  resolve(state);\n                }\n              })\n            );\n            if (hasResult) sub.unsubscribe();\n          }).then(onFulfilled, onRejected);\n        },\n      };\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  stops.push(\n    watchEffect(\n      onInvalidate => {\n        if (source.value) {\n          fetching.value = true;\n          stale.value = false;\n\n          onInvalidate(\n            pipe(\n              source.value,\n              onEnd(() => {\n                fetching.value = false;\n                stale.value = false;\n              }),\n              subscribe(res => {\n                data.value = res.data;\n                stale.value = !!res.stale;\n                fetching.value = false;\n                error.value = res.error;\n                operation.value = res.operation;\n                extensions.value = res.extensions;\n              })\n            ).unsubscribe\n          );\n        } else {\n          fetching.value = false;\n          stale.value = false;\n        }\n      },\n      {\n        // NOTE: This part of the query pipeline is only initialised once and will need\n        // to do so synchronously\n        flush: 'sync',\n      }\n    )\n  );\n\n  const response: UseQueryResponse<T, V> = {\n    ...state,\n    then(onFulfilled, onRejected) {\n      let sub: Subscription | void;\n      const promise = new Promise<UseQueryState<T, V>>(resolve => {\n        if (!source.value) return resolve(state);\n        let hasResult = false;\n        sub = pipe(\n          source.value,\n          subscribe(() => {\n            if (!state.fetching.value && !state.stale.value) {\n              if (sub) sub.unsubscribe();\n              hasResult = true;\n              resolve(state);\n            }\n          })\n        );\n        if (hasResult) sub.unsubscribe();\n      });\n\n      return promise.then(onFulfilled, onRejected);\n    },\n  };\n\n  return response;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { ref, Ref } from 'vue';\nimport { DocumentNode } from 'graphql';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport {\n  Client,\n  AnyVariables,\n  TypedDocumentNode,\n  CombinedError,\n  Operation,\n  OperationContext,\n  OperationResult,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy } from './utils';\n\n/** State of the last mutation executed by {@link useMutation}.\n *\n * @remarks\n * `UseMutationResponse` is returned by {@link useMutation} and\n * gives you the {@link OperationResult} of the last executed mutation,\n * and a {@link UseMutationResponse.executeMutation} method to\n * start mutations.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationResponse<T, V extends AnyVariables = AnyVariables> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: Ref<boolean>;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed mutation. */\n  data: Ref<T | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed mutation. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed mutation. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n   *\n   * @param variables - variables using which the mutation will be executed.\n   * @param context - optionally, context options that will be merged with\n   * {@link UseMutationArgs.context} and the `Client`’s options.\n   * @returns the {@link OperationResult} of the mutation.\n   *\n   * @remarks\n   * When called, {@link useMutation} will start the GraphQL mutation\n   * it currently holds and use the `variables` passed to it.\n   *\n   * Once the mutation response comes back from the API, its\n   * returned promise will resolve to the mutation’s {@link OperationResult}\n   * and the {@link UseMutationResponse} will be updated with the result.\n   *\n   * @example\n   * ```ts\n   * const result = useMutation(UpdateTodo);\n   * const start = async ({ id, title }) => {\n   *   const result = await result.executeMutation({ id, title });\n   * };\n   */\n  executeMutation(\n    variables: V,\n    context?: Partial<OperationContext>\n  ): Promise<OperationResult<T>>;\n}\n\n/** Function to create a GraphQL mutation, run by passing variables to {@link UseMutationResponse.executeMutation}\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} object.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined inside Vue `setup` functions,\n * and keeps its state after the mutation is started. Mutations can be started by calling\n * {@link UseMutationResponse.executeMutation} with variables.\n *\n * The returned result updates when a mutation is executed and keeps\n * track of the last mutation result.\n *\n * @see {@link https://urql.dev/goto/docs/basics/vue#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from '@urql/vue';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useMutation(UpdateTodo);\n *     const start = async ({ id, title }) => {\n *       const result = await result.executeMutation({ id, title });\n *     };\n *     // ...\n *   },\n * };\n * ```\n */\nexport function useMutation<T = any, V extends AnyVariables = AnyVariables>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string\n): UseMutationResponse<T, V> {\n  return callUseMutation(query);\n}\n\nexport function callUseMutation<T = any, V extends AnyVariables = AnyVariables>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string,\n  client: Ref<Client> = useClient()\n): UseMutationResponse<T, V> {\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  return {\n    data,\n    stale,\n    fetching,\n    error,\n    operation,\n    extensions,\n    executeMutation(\n      variables: V,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<T, V>> {\n      fetching.value = true;\n\n      return pipe(\n        client.value.executeMutation<T, V>(\n          createRequest<T, V>(query, unwrapPossibleProxy(variables)),\n          context || {}\n        ),\n        onPush(result => {\n          data.value = result.data;\n          stale.value = result.stale;\n          fetching.value = false;\n          error.value = result.error;\n          operation.value = result.operation;\n          extensions.value = result.extensions;\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n  };\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport {\n  WatchStopHandle,\n  Ref,\n  ref,\n  shallowRef,\n  watchEffect,\n  reactive,\n  isRef,\n} from 'vue';\n\nimport {\n  Client,\n  GraphQLRequestParams,\n  AnyVariables,\n  OperationResult,\n  CombinedError,\n  OperationContext,\n  Operation,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy, updateShallowRef } from './utils';\n\ntype MaybeRef<T> = Exclude<T, void> | Ref<Exclude<T, void>>;\ntype MaybeRefObj<T extends {}> = { [K in keyof T]: MaybeRef<T[K]> };\n\n/** Input arguments for the {@link useSubscription} function.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** Prevents {@link useSubscription} from automatically executing GraphQL subscription operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting\n   * its subscription automatically. This will pause the subscription until\n   * {@link UseSubscriptonState.resume} is called, or, if `pause` is a reactive\n   * ref of a boolean, until this ref changes to `true`.\n   */\n  pause?: MaybeRef<boolean>;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * const result = useQuery({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: MaybeRef<Partial<OperationContext>>;\n} & MaybeRefObj<GraphQLRequestParams<Data, Variables>>;\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionResponse.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const result = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** A {@link SubscriptionHandler} or a reactive ref of one. */\nexport type SubscriptionHandlerArg<T, R> = MaybeRef<SubscriptionHandler<T, R>>;\n\n/** State of the current query, your {@link useSubscription} function is executing.\n *\n * @remarks\n * `UseSubscriptionResponse` is returned by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * Each value that is part of the result is wrapped in a reactive ref\n * and updates as results come in.\n *\n * Hint: Even when the query and variables update, the prior state of\n * the last result is preserved.\n */\nexport interface UseSubscriptionResponse<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useSubscription`’s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or `useSubscription` is paused.\n   */\n  fetching: Ref<boolean>;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed subscription, or data returned by the handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data: Ref<R | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed subscription. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed mutation. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Indicates whether {@link useSubscription} is currently paused.\n   *\n   * @remarks\n   * When `useSubscription` has been paused, it will stop receiving updates\n   * from the {@link Client} and won’t execute the subscription, until\n   * {@link UseSubscriptionArgs.pause} becomes true or\n   * {@link UseSubscriptionResponse.resume} is called.\n   */\n  isPaused: Ref<boolean>;\n  /** Resumes {@link useSubscription} if it’s currently paused.\n   *\n   * @remarks\n   * Resumes or starts {@link useSubscription}’s subscription, if it’s currently paused.\n   */\n  resume(): void;\n  /** Pauses {@link useSubscription} to stop the subscription.\n   *\n   * @remarks\n   * Pauses {@link useSubscription}’s subscription, which stops it\n   * from receiving updates from the {@link Client} and to stop executing\n   * the subscription operation.\n   */\n  pause(): void;\n  /** Triggers {@link useQuery} to reexecute a GraphQL subscription operation.\n   *\n   * @param opts - optionally, context options that will be merged with\n   * {@link UseQueryArgs.context} and the `Client`’s options.\n   *\n   * @remarks\n   * When called, {@link useSubscription} will re-execute the GraphQL subscription\n   * operation it currently holds, unless it’s currently paused.\n   */\n  executeSubscription(opts?: Partial<OperationContext>): void;\n}\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\n/** Function to run a GraphQL subscription and get reactive GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} object.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed inside\n * Vue `setup` functions.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * provided {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from '@urql/vue';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useSubscription(\n *       { query: NotificationsSubscription },\n *       function combineNotifications(notifications = [], data) {\n *         return [...notifications, data.newNotification];\n *       },\n *     );\n *     // ...\n *   },\n * };\n * ```\n */\nexport function useSubscription<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<T, V>,\n  handler?: MaybeRef<SubscriptionHandler<T, R>>\n): UseSubscriptionResponse<T, R, V> {\n  return callUseSubscription(args, handler);\n}\n\nexport function callUseSubscription<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n>(\n  _args: UseSubscriptionArgs<T, V>,\n  handler?: MaybeRef<SubscriptionHandler<T, R>>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseSubscriptionResponse<T, R, V> {\n  const args = reactive(_args);\n\n  const data: Ref<R | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const scanHandler: Ref<SubscriptionHandler<T, R> | undefined> = ref(handler);\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const input = shallowRef({\n    request: createRequest<T, V>(\n      unwrapPossibleProxy(args.query as any),\n      unwrapPossibleProxy<V>(args.variables as V)\n    ),\n    isPaused: isPaused.value,\n  });\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      updateShallowRef(input, {\n        request: createRequest<T, V>(\n          unwrapPossibleProxy(args.query as any),\n          unwrapPossibleProxy<V>(args.variables as V)\n        ),\n        isPaused: isPaused.value,\n      });\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !isPaused.value\n        ? client.value.executeSubscription<T, V>(input.value.request, {\n            ...(unwrapPossibleProxy(args.context) as Partial<OperationContext>),\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(onInvalidate => {\n      if (source.value) {\n        fetching.value = true;\n\n        onInvalidate(\n          pipe(\n            source.value,\n            onEnd(() => {\n              fetching.value = false;\n            }),\n            subscribe(result => {\n              fetching.value = true;\n              (data.value =\n                result.data !== undefined\n                  ? typeof scanHandler.value === 'function'\n                    ? scanHandler.value(data.value as any, result.data!)\n                    : result.data\n                  : (result.data as any)),\n                (error.value = result.error);\n              extensions.value = result.extensions;\n              stale.value = !!result.stale;\n              operation.value = result.operation;\n            })\n          ).unsubscribe\n        );\n      } else {\n        fetching.value = false;\n      }\n    }, watchOptions)\n  );\n\n  const state: UseSubscriptionResponse<T, R, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeSubscription(\n      opts?: Partial<OperationContext>\n    ): UseSubscriptionResponse<T, R, V> {\n      source.value = client.value.executeSubscription<T, V>(\n        input.value.request,\n        {\n          ...unwrapPossibleProxy(args.context),\n          ...opts,\n        }\n      );\n\n      return state;\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  return state;\n}\n","import { DocumentNode } from 'graphql';\nimport { AnyVariables, Client, TypedDocumentNode } from '@urql/core';\nimport {\n  WatchStopHandle,\n  getCurrentInstance,\n  onMounted,\n  onBeforeUnmount,\n} from 'vue';\n\nimport { useClient } from './useClient';\n\nimport { callUseQuery, UseQueryArgs, UseQueryResponse } from './useQuery';\n\nimport { callUseMutation, UseMutationResponse } from './useMutation';\n\nimport {\n  callUseSubscription,\n  UseSubscriptionArgs,\n  SubscriptionHandlerArg,\n  UseSubscriptionResponse,\n} from './useSubscription';\n\n/** Handle to create GraphQL operations outside of Vue’s `setup` functions.\n *\n * @remarks\n * The `ClientHandle` object is created inside a Vue `setup` function but\n * allows its methods to be called outside of `setup` functions, delaying\n * the creation of GraphQL operations, as an alternative to pausing queries\n * or subscriptions.\n *\n * This is also important when chaining multiple functions inside an\n * `async setup()` function.\n *\n * Hint: If you only need a single, non-updating result and want to execute\n * queries programmatically, it may be easier to call the {@link Client.query}\n * method.\n */\nexport interface ClientHandle {\n  /** The {@link Client} that’ll be used to execute GraphQL operations. */\n  client: Client;\n\n  /** Calls {@link useQuery} outside of a synchronous Vue `setup` function.\n   *\n   * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n   * @returns a {@link UseQueryResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseQueryResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useQuery<T = any, V extends AnyVariables = AnyVariables>(\n    args: UseQueryArgs<T, V>\n  ): UseQueryResponse<T, V>;\n\n  /** Calls {@link useSubscription} outside of a synchronous Vue `setup` function.\n   *\n   * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n   * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n   * @returns a {@link UseSubscriptionResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseSubscriptionResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n    args: UseSubscriptionArgs<T, V>,\n    handler?: SubscriptionHandlerArg<T, R>\n  ): UseSubscriptionResponse<T, R, V>;\n\n  /** Calls {@link useMutation} outside of a synchronous Vue `setup` function.\n   *\n   * @param query - a GraphQL mutation document which `useMutation` will execute.\n   * @returns a {@link UseMutationResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseMutationResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useMutation<T = any, V extends AnyVariables = AnyVariables>(\n    query: TypedDocumentNode<T, V> | DocumentNode | string\n  ): UseMutationResponse<T, V>;\n}\n\n/** Creates a {@link ClientHandle} inside a Vue `setup` function.\n *\n * @remarks\n * `useClientHandle` creates and returns a {@link ClientHandle}\n * when called in a Vue `setup` function, which allows queries,\n * mutations, and subscriptions to be created _outside_ of\n * `setup` functions.\n *\n * This is also important when chaining multiple functions inside an\n * `async setup()` function.\n *\n * {@link useQuery} and other GraphQL functions must usually\n * be created in Vue `setup` functions so they can stop GraphQL\n * operations when your component unmounts. However, while they\n * queries and subscriptions can be paused, sometimes it’s easier\n * to delay the creation of their response objects.\n *\n *\n * @example\n * ```ts\n * import { ref, computed } from 'vue';\n * import { gql, useClientHandle } from '@urql/vue';\n *\n * export default {\n *   async setup() {\n *     const handle = useClientHandle();\n *\n *     const pokemons = await handle.useQuery({\n *       query: gql`{ pokemons(limit: 10) { id, name } }`,\n *     });\n *\n *     const index = ref(0);\n *\n *     // The `handle` allows another `useQuery` call to now be setup again\n *     const pokemon = await handle.useQuery({\n *       query: gql`\n *         query ($id: ID!) {\n *           pokemon(id: $id) { id, name }\n *         }\n *       `,\n *       variables: computed(() => ({\n *         id: pokemons.data.value.pokemons[index.value].id,\n *       }),\n *     });\n *   }\n * };\n * ```\n */\nexport function useClientHandle(): ClientHandle {\n  const client = useClient();\n  const stops: WatchStopHandle[] = [];\n\n  onBeforeUnmount(() => {\n    let stop: WatchStopHandle | void;\n    while ((stop = stops.shift())) stop();\n  });\n\n  const handle: ClientHandle = {\n    client: client.value,\n\n    useQuery<T = any, V extends AnyVariables = AnyVariables>(\n      args: UseQueryArgs<T, V>\n    ): UseQueryResponse<T, V> {\n      return callUseQuery(args, client, stops);\n    },\n\n    useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n      args: UseSubscriptionArgs<T, V>,\n      handler?: SubscriptionHandlerArg<T, R>\n    ): UseSubscriptionResponse<T, R, V> {\n      return callUseSubscription(args, handler, client, stops);\n    },\n\n    useMutation<T = any, V extends AnyVariables = AnyVariables>(\n      query: TypedDocumentNode<T, V> | DocumentNode | string\n    ): UseMutationResponse<T, V> {\n      return callUseMutation(query, client);\n    },\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    onMounted(() => {\n      Object.assign(handle, {\n        useQuery<T = any, V extends AnyVariables = AnyVariables>(\n          args: UseQueryArgs<T, V>\n        ): UseQueryResponse<T, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseQuery(args, client, stops);\n        },\n\n        useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n          args: UseSubscriptionArgs<T, V>,\n          handler?: SubscriptionHandlerArg<T, R>\n        ): UseSubscriptionResponse<T, R, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseSubscription(args, handler, client, stops);\n        },\n      });\n    });\n  }\n\n  return handle;\n}\n"],"names":["clientsPerInstance","WeakMap","provideClient","opts","client","isRef","ref","Client","instance","getCurrentInstance","set","provide","value","install","app","useClient","inject","get","unwrapPossibleProxy","possibleProxy","updateShallowRef","next","key","watchOptions","flush","useQuery","args","callUseQuery","_args","stops","reactive","data","stale","fetching","error","operation","extensions","isPaused","pause","input","shallowRef","request","createRequest","query","variables","requestPolicy","source","push","watchEffect","undefined","executeQuery","context","state","s","response","then","onFulfilled","onRejected","sub","Promise","resolve","hasResult","subscribe","unsubscribe","resume","onInvalidate","res","onEnd","useMutation","callUseMutation","executeMutation","toPromise","take","filter","result","hasNext","onPush","useSubscription","handler","callUseSubscription","scanHandler","executeSubscription","useClientHandle","onBeforeUnmount","stop","shift"],"mappings":"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"}