{"version":3,"file":"urql-vue.mjs","sources":["../src/useClient.ts","../src/utils.ts","../src/useQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useClientHandle.ts"],"sourcesContent":["import { App, getCurrentInstance, inject, provide, Ref, isRef, ref } from 'vue';\nimport { Client, ClientOptions } from '@urql/core';\n\nconst clientsPerInstance = new WeakMap<{}, Ref<Client>>();\n\n/** Provides a {@link Client} to a component’s children.\n *\n * @param opts - {@link ClientOptions}, a {@link Client}, or a reactive ref object of a `Client`.\n *\n * @remarks\n * `provideClient` provides a {@link Client} to `@urql/vue`’s GraphQL\n * functions in children components.\n *\n * Hint: GraphQL functions and {@link useClient} will see the\n * provided `Client`, even if `provideClient` has been called\n * in the same component’s `setup` function.\n *\n * @example\n * ```ts\n * import { provideClient } from '@urql/vue';\n * // All of `@urql/core` is also re-exported by `@urql/vue`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * export default {\n *   setup() {\n *     provideClient(new Client({\n *       url: 'https://API',\n *       exchanges: [cacheExchange, fetchExchange],\n *     }));\n *   },\n * };\n * ```\n */\nexport function provideClient(opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n\n  const instance = getCurrentInstance();\n  if (instance) {\n    clientsPerInstance.set(instance, client);\n  }\n\n  provide('$urql', client);\n  return client.value;\n}\n\n/** Provides a {@link Client} to a Vue app.\n *\n * @param app - the Vue {@link App}\n * @param opts - {@link ClientOptions}, a {@link Client}, or a reactive ref object of a `Client`.\n *\n * @remarks\n * `install` provides a {@link Client} to `@urql/vue`’s GraphQL\n * functions in a Vue app.\n *\n * @example\n * ```ts\n * import * as urql from '@urql/vue';\n * // All of `@urql/core` is also re-exported by `@urql/vue`:\n * import { cacheExchange, fetchExchange } from '@urql/core';\n *\n * import { createApp } from 'vue';\n * import Root from './App.vue';\n *\n * const app = createApp(Root);\n * app.use(urql, {\n *   url: 'http://localhost:3000/graphql',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n * ```\n */\nexport function install(app: App, opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n  app.provide('$urql', client);\n}\n\n/** Returns a provided reactive ref object of a {@link Client}.\n *\n * @remarks\n * `useClient` may be called in Vue `setup` functions to retrieve a\n * reactive rev object of a {@link Client} that’s previously been\n * provided with {@link provideClient} in the current or a parent’s\n * `setup` function.\n *\n * @throws\n * In development, if `useClient` is called outside of a Vue `setup`\n * function or no {@link Client} was provided, an error will be thrown.\n */\nexport function useClient(): Ref<Client> {\n  const instance = getCurrentInstance();\n  if (process.env.NODE_ENV !== 'production' && !instance) {\n    throw new Error(\n      'use* functions may only be called during the `setup()` or other lifecycle hooks.'\n    );\n  }\n\n  let client = inject('$urql') as Ref<Client> | undefined;\n  if (!client && instance) {\n    client = clientsPerInstance.get(instance);\n  }\n\n  if (process.env.NODE_ENV !== 'production' && !client) {\n    throw new Error(\n      'No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?'\n    );\n  }\n\n  return client!;\n}\n","import { GraphQLRequest, AnyVariables } from '@urql/core';\nimport { Ref, ShallowRef, isRef } from 'vue';\n\nexport function unwrapPossibleProxy<V>(possibleProxy: V | Ref<V>): V {\n  return possibleProxy && isRef(possibleProxy)\n    ? possibleProxy.value\n    : possibleProxy;\n}\n\nexport interface RequestState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  request: GraphQLRequest<Data, Variables>;\n  isPaused: boolean;\n}\n\nexport function createRequestState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  request: GraphQLRequest<Data, Variables>,\n  isPaused: boolean\n): RequestState<Data, Variables> {\n  return { request, isPaused };\n}\n\nexport const updateShallowRef = <T extends Record<string, any>>(\n  ref: ShallowRef<T>,\n  next: T\n) => {\n  for (const key in next) {\n    if (ref.value[key] !== next[key]) {\n      ref.value = next;\n      return;\n    }\n  }\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport {\n  WatchStopHandle,\n  Ref,\n  shallowRef,\n  ref,\n  watchEffect,\n  reactive,\n  isRef,\n} from 'vue';\n\nimport { Subscription, Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport {\n  Client,\n  AnyVariables,\n  OperationResult,\n  GraphQLRequestParams,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  Operation,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy, updateShallowRef } from './utils';\n\ntype MaybeRef<T> = T | Ref<T>;\ntype MaybeRefObj<T extends {}> = { [K in keyof T]: MaybeRef<T[K]> };\n\n/** Input arguments for the {@link useQuery} function.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: MaybeRef<RequestPolicy>;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * const result = useQuery({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: MaybeRef<Partial<OperationContext>>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. This will pause the query until {@link UseQueryState.resume}\n   * is called, or, if `pause` is a reactive ref of a boolean, until this\n   * ref changes to `true`.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: MaybeRef<boolean>;\n} & MaybeRefObj<GraphQLRequestParams<Data, Variables>>;\n\n/** State of the current query, your {@link useQuery} function is executing.\n *\n * @remarks\n * `UseQueryState` is returned by {@link useQuery} and\n * gives you the updating {@link OperationResult} of\n * GraphQL queries.\n *\n * Each value that is part of the result is wrapped in a reactive ref\n * and updates as results come in.\n *\n * Hint: Even when the query and variables update, the previous state of\n * the last result is preserved, which allows you to display the\n * previous state, while implementing a loading indicator separately.\n */\nexport interface UseQueryState<T = any, V extends AnyVariables = AnyVariables> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` receives a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: Ref<boolean>;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed query. */\n  data: Ref<T | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed query. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed query. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Indicates whether {@link useQuery} is currently paused.\n   *\n   * @remarks\n   * When `useQuery` has been paused, it will stop receiving updates\n   * from the {@link Client} and won’t execute query operations, until\n   * {@link UseQueryArgs.pause} becomes `true` or {@link UseQueryState.resume}\n   * is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  isPaused: Ref<boolean>;\n  /** Resumes {@link useQuery} if it’s currently paused.\n   *\n   * @remarks\n   * Resumes or starts {@link useQuery}’s query, if it’s currently paused.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  resume(): void;\n  /** Pauses {@link useQuery} to stop it from executing the query.\n   *\n   * @remarks\n   * Pauses {@link useQuery}’s query, which stops it from receiving updates\n   * from the {@link Client} and to stop the ongoing query operation.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/vue#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause(): void;\n  /** Triggers {@link useQuery} to execute a new GraphQL query operation.\n   *\n   * @param opts - optionally, context options that will be merged with\n   * {@link UseQueryArgs.context} and the `Client`’s options.\n   *\n   * @remarks\n   * When called, {@link useQuery} will re-execute the GraphQL query operation\n   * it currently holds, unless it’s currently paused.\n   *\n   * This is useful for re-executing a query and get a new network result,\n   * by passing a new request policy.\n   *\n   * ```ts\n   * const result = useQuery({ query });\n   *\n   * const refresh = () => {\n   *   // Re-execute the query with a network-only policy, skipping the cache\n   *   result.executeQuery({ requestPolicy: 'network-only' });\n   * };\n   * ```\n   */\n  executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V>;\n}\n\n/** Return value of {@link useQuery}, which is an awaitable {@link UseQueryState}.\n *\n * @remarks\n * {@link useQuery} returns a {@link UseQueryState} but may also be\n * awaited inside a Vue `async setup()` function. If it’s awaited\n * the query is executed before resolving.\n */\nexport type UseQueryResponse<\n  T,\n  V extends AnyVariables = AnyVariables\n> = UseQueryState<T, V> & PromiseLike<UseQueryState<T, V>>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\n/** Function to run a GraphQL query and get reactive GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} object.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed inside\n * Vue `setup` functions.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * provided {@link Client}.\n *\n * The returned result’s reactive values update when the `Client` has\n * new results for the query, and changes when your input `args` change.\n *\n * Additionally, `useQuery` may also be awaited inside an `async setup()`\n * function to use Vue’s Suspense feature.\n *\n * @see {@link https://urql.dev/goto/docs/basics/vue#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from '@urql/vue';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useQuery({ query: TodosQuery });\n *     return { data: result.data };\n *   },\n * };\n * ```\n */\nexport function useQuery<T = any, V extends AnyVariables = AnyVariables>(\n  args: UseQueryArgs<T, V>\n): UseQueryResponse<T, V> {\n  return callUseQuery(args);\n}\n\nexport function callUseQuery<T = any, V extends AnyVariables = AnyVariables>(\n  _args: UseQueryArgs<T, V>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseQueryResponse<T, V> {\n  const args = reactive(_args);\n\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const input = shallowRef({\n    request: createRequest<T, V>(\n      unwrapPossibleProxy(args.query as any),\n      unwrapPossibleProxy<V>(args.variables as V)\n    ),\n    requestPolicy: unwrapPossibleProxy(args.requestPolicy),\n    isPaused: isPaused.value,\n  });\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      updateShallowRef(input, {\n        request: createRequest<T, V>(\n          unwrapPossibleProxy(args.query as any),\n          unwrapPossibleProxy<V>(args.variables as V)\n        ),\n        requestPolicy: unwrapPossibleProxy(args.requestPolicy),\n        isPaused: isPaused.value,\n      });\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !input.value.isPaused\n        ? client.value.executeQuery<T, V>(input.value.request, {\n            requestPolicy: unwrapPossibleProxy(\n              args.requestPolicy\n            ) as RequestPolicy,\n            ...unwrapPossibleProxy(args.context),\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  const state: UseQueryState<T, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V> {\n      const s = (source.value = client.value.executeQuery<T, V>(\n        input.value.request,\n        {\n          requestPolicy: unwrapPossibleProxy(\n            args.requestPolicy\n          ) as RequestPolicy,\n          ...args.context,\n          ...opts,\n        }\n      ));\n\n      return {\n        ...response,\n        then(onFulfilled, onRejected) {\n          let sub: Subscription | void;\n          return new Promise<UseQueryState<T, V>>(resolve => {\n            let hasResult = false;\n            sub = pipe(\n              s,\n              subscribe(() => {\n                if (!state.fetching.value && !state.stale.value) {\n                  if (sub) sub.unsubscribe();\n                  hasResult = true;\n                  resolve(state);\n                }\n              })\n            );\n            if (hasResult) sub.unsubscribe();\n          }).then(onFulfilled, onRejected);\n        },\n      };\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  stops.push(\n    watchEffect(\n      onInvalidate => {\n        if (source.value) {\n          fetching.value = true;\n          stale.value = false;\n\n          onInvalidate(\n            pipe(\n              source.value,\n              onEnd(() => {\n                fetching.value = false;\n                stale.value = false;\n              }),\n              subscribe(res => {\n                data.value = res.data;\n                stale.value = !!res.stale;\n                fetching.value = false;\n                error.value = res.error;\n                operation.value = res.operation;\n                extensions.value = res.extensions;\n              })\n            ).unsubscribe\n          );\n        } else {\n          fetching.value = false;\n          stale.value = false;\n        }\n      },\n      {\n        // NOTE: This part of the query pipeline is only initialised once and will need\n        // to do so synchronously\n        flush: 'sync',\n      }\n    )\n  );\n\n  const response: UseQueryResponse<T, V> = {\n    ...state,\n    then(onFulfilled, onRejected) {\n      let sub: Subscription | void;\n      const promise = new Promise<UseQueryState<T, V>>(resolve => {\n        if (!source.value) return resolve(state);\n        let hasResult = false;\n        sub = pipe(\n          source.value,\n          subscribe(() => {\n            if (!state.fetching.value && !state.stale.value) {\n              if (sub) sub.unsubscribe();\n              hasResult = true;\n              resolve(state);\n            }\n          })\n        );\n        if (hasResult) sub.unsubscribe();\n      });\n\n      return promise.then(onFulfilled, onRejected);\n    },\n  };\n\n  return response;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { ref, Ref } from 'vue';\nimport { DocumentNode } from 'graphql';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport {\n  Client,\n  AnyVariables,\n  TypedDocumentNode,\n  CombinedError,\n  Operation,\n  OperationContext,\n  OperationResult,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy } from './utils';\n\n/** State of the last mutation executed by {@link useMutation}.\n *\n * @remarks\n * `UseMutationResponse` is returned by {@link useMutation} and\n * gives you the {@link OperationResult} of the last executed mutation,\n * and a {@link UseMutationResponse.executeMutation} method to\n * start mutations.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationResponse<T, V extends AnyVariables = AnyVariables> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: Ref<boolean>;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed mutation. */\n  data: Ref<T | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed mutation. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed mutation. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n   *\n   * @param variables - variables using which the mutation will be executed.\n   * @param context - optionally, context options that will be merged with\n   * {@link UseMutationArgs.context} and the `Client`’s options.\n   * @returns the {@link OperationResult} of the mutation.\n   *\n   * @remarks\n   * When called, {@link useMutation} will start the GraphQL mutation\n   * it currently holds and use the `variables` passed to it.\n   *\n   * Once the mutation response comes back from the API, its\n   * returned promise will resolve to the mutation’s {@link OperationResult}\n   * and the {@link UseMutationResponse} will be updated with the result.\n   *\n   * @example\n   * ```ts\n   * const result = useMutation(UpdateTodo);\n   * const start = async ({ id, title }) => {\n   *   const result = await result.executeMutation({ id, title });\n   * };\n   */\n  executeMutation(\n    variables: V,\n    context?: Partial<OperationContext>\n  ): Promise<OperationResult<T>>;\n}\n\n/** Function to create a GraphQL mutation, run by passing variables to {@link UseMutationResponse.executeMutation}\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} object.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined inside Vue `setup` functions,\n * and keeps its state after the mutation is started. Mutations can be started by calling\n * {@link UseMutationResponse.executeMutation} with variables.\n *\n * The returned result updates when a mutation is executed and keeps\n * track of the last mutation result.\n *\n * @see {@link https://urql.dev/goto/docs/basics/vue#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from '@urql/vue';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useMutation(UpdateTodo);\n *     const start = async ({ id, title }) => {\n *       const result = await result.executeMutation({ id, title });\n *     };\n *     // ...\n *   },\n * };\n * ```\n */\nexport function useMutation<T = any, V extends AnyVariables = AnyVariables>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string\n): UseMutationResponse<T, V> {\n  return callUseMutation(query);\n}\n\nexport function callUseMutation<T = any, V extends AnyVariables = AnyVariables>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string,\n  client: Ref<Client> = useClient()\n): UseMutationResponse<T, V> {\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  return {\n    data,\n    stale,\n    fetching,\n    error,\n    operation,\n    extensions,\n    executeMutation(\n      variables: V,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<T, V>> {\n      fetching.value = true;\n\n      return pipe(\n        client.value.executeMutation<T, V>(\n          createRequest<T, V>(query, unwrapPossibleProxy(variables)),\n          context || {}\n        ),\n        onPush(result => {\n          data.value = result.data;\n          stale.value = result.stale;\n          fetching.value = false;\n          error.value = result.error;\n          operation.value = result.operation;\n          extensions.value = result.extensions;\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n  };\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport {\n  WatchStopHandle,\n  Ref,\n  ref,\n  shallowRef,\n  watchEffect,\n  reactive,\n  isRef,\n} from 'vue';\n\nimport {\n  Client,\n  GraphQLRequestParams,\n  AnyVariables,\n  OperationResult,\n  CombinedError,\n  OperationContext,\n  Operation,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy, updateShallowRef } from './utils';\n\ntype MaybeRef<T> = Exclude<T, void> | Ref<Exclude<T, void>>;\ntype MaybeRefObj<T extends {}> = { [K in keyof T]: MaybeRef<T[K]> };\n\n/** Input arguments for the {@link useSubscription} function.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** Prevents {@link useSubscription} from automatically executing GraphQL subscription operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting\n   * its subscription automatically. This will pause the subscription until\n   * {@link UseSubscriptonState.resume} is called, or, if `pause` is a reactive\n   * ref of a boolean, until this ref changes to `true`.\n   */\n  pause?: MaybeRef<boolean>;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * const result = useQuery({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: MaybeRef<Partial<OperationContext>>;\n} & MaybeRefObj<GraphQLRequestParams<Data, Variables>>;\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionResponse.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const result = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** A {@link SubscriptionHandler} or a reactive ref of one. */\nexport type SubscriptionHandlerArg<T, R> = MaybeRef<SubscriptionHandler<T, R>>;\n\n/** State of the current query, your {@link useSubscription} function is executing.\n *\n * @remarks\n * `UseSubscriptionResponse` is returned by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * Each value that is part of the result is wrapped in a reactive ref\n * and updates as results come in.\n *\n * Hint: Even when the query and variables update, the prior state of\n * the last result is preserved.\n */\nexport interface UseSubscriptionResponse<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useSubscription`’s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or `useSubscription` is paused.\n   */\n  fetching: Ref<boolean>;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: Ref<boolean>;\n  /** Reactive {@link OperationResult.data} for the executed subscription, or data returned by the handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data: Ref<R | undefined>;\n  /** Reactive {@link OperationResult.error} for the executed subscription. */\n  error: Ref<CombinedError | undefined>;\n  /** Reactive {@link OperationResult.extensions} for the executed mutation. */\n  extensions: Ref<Record<string, any> | undefined>;\n  /** Reactive {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation: Ref<Operation<T, V> | undefined>;\n  /** Indicates whether {@link useSubscription} is currently paused.\n   *\n   * @remarks\n   * When `useSubscription` has been paused, it will stop receiving updates\n   * from the {@link Client} and won’t execute the subscription, until\n   * {@link UseSubscriptionArgs.pause} becomes true or\n   * {@link UseSubscriptionResponse.resume} is called.\n   */\n  isPaused: Ref<boolean>;\n  /** Resumes {@link useSubscription} if it’s currently paused.\n   *\n   * @remarks\n   * Resumes or starts {@link useSubscription}’s subscription, if it’s currently paused.\n   */\n  resume(): void;\n  /** Pauses {@link useSubscription} to stop the subscription.\n   *\n   * @remarks\n   * Pauses {@link useSubscription}’s subscription, which stops it\n   * from receiving updates from the {@link Client} and to stop executing\n   * the subscription operation.\n   */\n  pause(): void;\n  /** Triggers {@link useQuery} to reexecute a GraphQL subscription operation.\n   *\n   * @param opts - optionally, context options that will be merged with\n   * {@link UseQueryArgs.context} and the `Client`’s options.\n   *\n   * @remarks\n   * When called, {@link useSubscription} will re-execute the GraphQL subscription\n   * operation it currently holds, unless it’s currently paused.\n   */\n  executeSubscription(opts?: Partial<OperationContext>): void;\n}\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\n/** Function to run a GraphQL subscription and get reactive GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} object.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed inside\n * Vue `setup` functions.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * provided {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from '@urql/vue';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * export default {\n *   setup() {\n *     const result = useSubscription(\n *       { query: NotificationsSubscription },\n *       function combineNotifications(notifications = [], data) {\n *         return [...notifications, data.newNotification];\n *       },\n *     );\n *     // ...\n *   },\n * };\n * ```\n */\nexport function useSubscription<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<T, V>,\n  handler?: MaybeRef<SubscriptionHandler<T, R>>\n): UseSubscriptionResponse<T, R, V> {\n  return callUseSubscription(args, handler);\n}\n\nexport function callUseSubscription<\n  T = any,\n  R = T,\n  V extends AnyVariables = AnyVariables\n>(\n  _args: UseSubscriptionArgs<T, V>,\n  handler?: MaybeRef<SubscriptionHandler<T, R>>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseSubscriptionResponse<T, R, V> {\n  const args = reactive(_args);\n\n  const data: Ref<R | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const scanHandler: Ref<SubscriptionHandler<T, R> | undefined> = ref(handler);\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const input = shallowRef({\n    request: createRequest<T, V>(\n      unwrapPossibleProxy(args.query as any),\n      unwrapPossibleProxy<V>(args.variables as V)\n    ),\n    isPaused: isPaused.value,\n  });\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      updateShallowRef(input, {\n        request: createRequest<T, V>(\n          unwrapPossibleProxy(args.query as any),\n          unwrapPossibleProxy<V>(args.variables as V)\n        ),\n        isPaused: isPaused.value,\n      });\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !isPaused.value\n        ? client.value.executeSubscription<T, V>(input.value.request, {\n            ...(unwrapPossibleProxy(args.context) as Partial<OperationContext>),\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(onInvalidate => {\n      if (source.value) {\n        fetching.value = true;\n\n        onInvalidate(\n          pipe(\n            source.value,\n            onEnd(() => {\n              fetching.value = false;\n            }),\n            subscribe(result => {\n              fetching.value = true;\n              (data.value =\n                result.data !== undefined\n                  ? typeof scanHandler.value === 'function'\n                    ? scanHandler.value(data.value as any, result.data!)\n                    : result.data\n                  : (result.data as any)),\n                (error.value = result.error);\n              extensions.value = result.extensions;\n              stale.value = !!result.stale;\n              operation.value = result.operation;\n            })\n          ).unsubscribe\n        );\n      } else {\n        fetching.value = false;\n      }\n    }, watchOptions)\n  );\n\n  const state: UseSubscriptionResponse<T, R, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeSubscription(\n      opts?: Partial<OperationContext>\n    ): UseSubscriptionResponse<T, R, V> {\n      source.value = client.value.executeSubscription<T, V>(\n        input.value.request,\n        {\n          ...unwrapPossibleProxy(args.context),\n          ...opts,\n        }\n      );\n\n      return state;\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  return state;\n}\n","import { DocumentNode } from 'graphql';\nimport { AnyVariables, Client, TypedDocumentNode } from '@urql/core';\nimport {\n  WatchStopHandle,\n  getCurrentInstance,\n  onMounted,\n  onBeforeUnmount,\n} from 'vue';\n\nimport { useClient } from './useClient';\n\nimport { callUseQuery, UseQueryArgs, UseQueryResponse } from './useQuery';\n\nimport { callUseMutation, UseMutationResponse } from './useMutation';\n\nimport {\n  callUseSubscription,\n  UseSubscriptionArgs,\n  SubscriptionHandlerArg,\n  UseSubscriptionResponse,\n} from './useSubscription';\n\n/** Handle to create GraphQL operations outside of Vue’s `setup` functions.\n *\n * @remarks\n * The `ClientHandle` object is created inside a Vue `setup` function but\n * allows its methods to be called outside of `setup` functions, delaying\n * the creation of GraphQL operations, as an alternative to pausing queries\n * or subscriptions.\n *\n * This is also important when chaining multiple functions inside an\n * `async setup()` function.\n *\n * Hint: If you only need a single, non-updating result and want to execute\n * queries programmatically, it may be easier to call the {@link Client.query}\n * method.\n */\nexport interface ClientHandle {\n  /** The {@link Client} that’ll be used to execute GraphQL operations. */\n  client: Client;\n\n  /** Calls {@link useQuery} outside of a synchronous Vue `setup` function.\n   *\n   * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n   * @returns a {@link UseQueryResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseQueryResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useQuery<T = any, V extends AnyVariables = AnyVariables>(\n    args: UseQueryArgs<T, V>\n  ): UseQueryResponse<T, V>;\n\n  /** Calls {@link useSubscription} outside of a synchronous Vue `setup` function.\n   *\n   * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n   * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n   * @returns a {@link UseSubscriptionResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseSubscriptionResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n    args: UseSubscriptionArgs<T, V>,\n    handler?: SubscriptionHandlerArg<T, R>\n  ): UseSubscriptionResponse<T, R, V>;\n\n  /** Calls {@link useMutation} outside of a synchronous Vue `setup` function.\n   *\n   * @param query - a GraphQL mutation document which `useMutation` will execute.\n   * @returns a {@link UseMutationResponse} object.\n   *\n   * @remarks\n   * Creates a {@link UseMutationResponse} outside of a synchronous Vue `setup`\n   * function or when chained in an `async setup()` function.\n   */\n  useMutation<T = any, V extends AnyVariables = AnyVariables>(\n    query: TypedDocumentNode<T, V> | DocumentNode | string\n  ): UseMutationResponse<T, V>;\n}\n\n/** Creates a {@link ClientHandle} inside a Vue `setup` function.\n *\n * @remarks\n * `useClientHandle` creates and returns a {@link ClientHandle}\n * when called in a Vue `setup` function, which allows queries,\n * mutations, and subscriptions to be created _outside_ of\n * `setup` functions.\n *\n * This is also important when chaining multiple functions inside an\n * `async setup()` function.\n *\n * {@link useQuery} and other GraphQL functions must usually\n * be created in Vue `setup` functions so they can stop GraphQL\n * operations when your component unmounts. However, while they\n * queries and subscriptions can be paused, sometimes it’s easier\n * to delay the creation of their response objects.\n *\n *\n * @example\n * ```ts\n * import { ref, computed } from 'vue';\n * import { gql, useClientHandle } from '@urql/vue';\n *\n * export default {\n *   async setup() {\n *     const handle = useClientHandle();\n *\n *     const pokemons = await handle.useQuery({\n *       query: gql`{ pokemons(limit: 10) { id, name } }`,\n *     });\n *\n *     const index = ref(0);\n *\n *     // The `handle` allows another `useQuery` call to now be setup again\n *     const pokemon = await handle.useQuery({\n *       query: gql`\n *         query ($id: ID!) {\n *           pokemon(id: $id) { id, name }\n *         }\n *       `,\n *       variables: computed(() => ({\n *         id: pokemons.data.value.pokemons[index.value].id,\n *       }),\n *     });\n *   }\n * };\n * ```\n */\nexport function useClientHandle(): ClientHandle {\n  const client = useClient();\n  const stops: WatchStopHandle[] = [];\n\n  onBeforeUnmount(() => {\n    let stop: WatchStopHandle | void;\n    while ((stop = stops.shift())) stop();\n  });\n\n  const handle: ClientHandle = {\n    client: client.value,\n\n    useQuery<T = any, V extends AnyVariables = AnyVariables>(\n      args: UseQueryArgs<T, V>\n    ): UseQueryResponse<T, V> {\n      return callUseQuery(args, client, stops);\n    },\n\n    useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n      args: UseSubscriptionArgs<T, V>,\n      handler?: SubscriptionHandlerArg<T, R>\n    ): UseSubscriptionResponse<T, R, V> {\n      return callUseSubscription(args, handler, client, stops);\n    },\n\n    useMutation<T = any, V extends AnyVariables = AnyVariables>(\n      query: TypedDocumentNode<T, V> | DocumentNode | string\n    ): UseMutationResponse<T, V> {\n      return callUseMutation(query, client);\n    },\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    onMounted(() => {\n      Object.assign(handle, {\n        useQuery<T = any, V extends AnyVariables = AnyVariables>(\n          args: UseQueryArgs<T, V>\n        ): UseQueryResponse<T, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseQuery(args, client, stops);\n        },\n\n        useSubscription<T = any, R = T, V extends AnyVariables = AnyVariables>(\n          args: UseSubscriptionArgs<T, V>,\n          handler?: SubscriptionHandlerArg<T, R>\n        ): UseSubscriptionResponse<T, R, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseSubscription(args, handler, client, stops);\n        },\n      });\n    });\n  }\n\n  return handle;\n}\n"],"names":["clientsPerInstance","WeakMap","provideClient","opts","client","isRef","ref","Client","instance","getCurrentInstance","set","provide","value","install","app","useClient","process","env","NODE_ENV","Error","inject","get","unwrapPossibleProxy","possibleProxy","updateShallowRef","next","key","watchOptions","flush","useQuery","args","callUseQuery","_args","stops","reactive","data","stale","fetching","error","operation","extensions","isPaused","pause","input","shallowRef","request","createRequest","query","variables","requestPolicy","source","push","watchEffect","executeQuery","context","undefined","state","s","response","then","onFulfilled","onRejected","sub","Promise","resolve","hasResult","subscribe","unsubscribe","resume","onInvalidate","res","onEnd","useMutation","callUseMutation","executeMutation","toPromise","take","filter","result","hasNext","onPush","useSubscription","handler","callUseSubscription","scanHandler","executeSubscription","useClientHandle","onBeforeUnmount","stop","shift","handle","onMounted","Object","assign"],"mappings":"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"}